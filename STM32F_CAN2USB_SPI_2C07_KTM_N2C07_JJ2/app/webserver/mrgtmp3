/**
 * \addtogroup apps
 * @{
 */

/**
 * \defgroup httpd Web server
 * @{
 * The uIP web server is a very simplistic implementation of an HTTP
 * server. It can serve web pages and files from a read-only ROM
 * filesystem, and provides a very small scripting language.

 */

/**
 * \file
 *         Web server
 * \author
 *         Adam Dunkels <adam@sics.se>
 */


/*
 * Copyright (c) 2004, Adam Dunkels.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the uIP TCP/IP stack.
 *
 * Author: Adam Dunkels <adam@sics.se>
 *
 * $Id: httpd.c,v 1.2 2006/06/11 21:46:38 adam Exp $
 */

#include "uip.h"
#include "httpd.h"
#include "httpd-fs.h"
#include "httpd-cgi.h"
#include "http-strings.h"

#include <string.h>
#include "def_generation.h"
#include "web_led.h"

#define STATE_WAITING 0
#define STATE_OUTPUT  1

#define ISO_nl      0x0a
#define ISO_space   0x20
#define ISO_bang    0x21
#define ISO_percent 0x25
#define ISO_period  0x2e
#define ISO_slash   0x2f
#define ISO_colon   0x3a

char *SelectBtnDemoSTR=  "iProbe3.3"; //"iProbe web003.3"
char *szLedOpDemoSTR= "LED"; //"LED processing"

static const char zAboutText[] = { 'A','b','o','u','t', 0}; //{ 'A','b','o','u','t',' ','i','P','r','o','b','e', 0};
static const char zInit[] = { 'i','P','r','o','b','e','3','.','3', 0}; //{ 'i','P','r','o','b','e',' ','w','e','b','0','0','3','.','3', 0};

char *pDemoText= (char *) zAboutText;
char *pDemoSTR= (char *) zInit;

u16_t arp_wbit[16]; 
static u8_t probe_dispc= 0;

u8_t probe_index, probe_fc, probc_prev;

#define PSCK_ARG_NoUSE NULL
#define IN_PADDING_WIDTH 10 //786-10 table_width=
#define LEN_IF_TAB_CONCLUSION (79+23+41) //This is trtde(mcount)/79, tabstart_bkgndcolor(mcount)/23, trtds(mcount)/41	
#define DMIP3	((uip_hostaddr[1] >> 8)&0xff) //TEST +1 //(((uip_hostaddr[1] >> 8)&0xff) + 1)  
#define BROWSERIP3 ((uip_conn->ripaddr[1] >> 8)&0xff)

void icmptab_clr_arp_wbit(u8_t adrr)
{
	arp_wbit[adrr / 16] &= ~(1 << (adrr % 16)); 
}
void icmptab_set_arp_wbit1org(u8_t adrr)
{
	arp_wbit[adrr / 16] |= 1 << (adrr % 16); 
}
//for 'icmptab_get_arp_wbit'
void icmptab_init_arp_wbit(void)
{
	int i;
	for (i=0; i<16; i++)
		arp_wbit[i]= 0;
	icmptab_set_arp_wbit1org(DMIP3); // device-self-added
		
	#if 0
	//for (i=0; i< 256; i++)
	//	if (i&1)
	//		icmptab_set_arp_wbit1org( (u8_t)i);
	//icmptab_clr_arp_wbit(0);
	//icmptab_clr_arp_wbit(255);
	#endif
}
char /*bit*/ icmptab_get_arp_wbit(u8_t adrr)
{
	//return arp_wbit[adrr / 16] >> (adrr % 16); //return value type: bit
	//return (arp_wbit[adrr / 16] >> (adrr % 16)) & 0x1; //return value type: char
	  return (arp_wbit[adrr / 16] >> (adrr % 16)) & 0x1;
}
/*-----------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
static u8_t
httpd_fs_strcmp(const char *str1, const char *str2)
{
  u8_t i;
  i = 0;
 loop:

  if(str1[i] == 0) {
		//_PR2("_httpd_fs_strcmpt: str1[%d] - is 0", i);
    return 0;
	}
		
  if(str2[i] == 0 ||
     str1[i] == '\r' ||
     str1[i] == '\n') {
    return 0;
  }

  if(str1[i] != str2[i]) {
    return 1;
  }


  ++i;
  goto loop;
}
/*-----------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#define MAX_WIDTH_PX 786 //max-width:786px

int page_start_meta_head_title1_a(char *strptr) //(, char refresh_continue)
{
  int mcount= 0;

  mcount += sprintf((strptr + mcount),"body{");
  mcount += sprintf((strptr + mcount),"text-align:center;");
  mcount += sprintf((strptr + mcount),"font:12px Verdana;");
  mcount += sprintf((strptr + mcount),"color:black;");
  mcount += sprintf((strptr + mcount),"padding:0px;");
  mcount += sprintf((strptr + mcount),"margin:0px;}");
  mcount += sprintf((strptr + mcount),".content{");
  mcount += sprintf((strptr + mcount),"max-width:%dpx;", MAX_WIDTH_PX); //786
  mcount += sprintf((strptr + mcount),"margin:auto;}");
  mcount += sprintf((strptr + mcount),".top_content{");
  mcount += sprintf((strptr + mcount),"height:100px;");
  mcount += sprintf((strptr + mcount),"border:2px solid #0067AC;");
  mcount += sprintf((strptr + mcount),"margin-top:10px;}");
  
  mcount += sprintf((strptr + mcount),".top{");
  mcount += sprintf((strptr + mcount),"background-color:#0067AC;");
  mcount += sprintf((strptr + mcount),"color:white;");
  mcount += sprintf((strptr + mcount),"font-size:0.9em;}");
    
  return mcount;
}
int page_start_meta_head_title1_b(char *strptr) //(, char refresh_continue)
{
  int mcount= 0;
  mcount += sprintf((strptr + mcount),".top p{");
  mcount += sprintf((strptr + mcount),"margin:0px;");
  mcount += sprintf((strptr + mcount),"height:20px;");
  mcount += sprintf((strptr + mcount),"line-height:25px;}");
  mcount += sprintf((strptr + mcount),".prgss{");
  mcount += sprintf((strptr + mcount),"font-size:0.9em;");
  //mcount += sprintf((strptr + mcount),"margin-top:3px;margin-bottom:3px;}");
  mcount += sprintf((strptr + mcount),"margin:3px;}\n");
  mcount += sprintf((strptr + mcount),".w{width:33px}");
#if 1 
//test-
  mcount += sprintf((strptr + mcount),"input[type=sbx]{background-color:#BEFFDE;}");
  mcount += sprintf((strptr + mcount),"input[type=cbx]{background-color:#EEFFFF;}");
#endif  
  mcount += sprintf((strptr + mcount),"input[type=x]{color:Brown;}");
  mcount += sprintf((strptr + mcount),"input[type=y]{color:Blue;}");
  mcount += sprintf((strptr + mcount),"input[type=b]{color:black;}");
  mcount += sprintf((strptr + mcount),"input[type=r]{color:red;}");
  return mcount;
}

int page_start_meta_head_title2(char *sptr) //(, char refresh_continue)
{
  int mcount= 0;

#if 1
	/*
	<script>
	function myFunction() {
    	  document.getElementById("demo").innerHTML = "xxx";
	}
	</script>
	 */
    /* Java Scrupt code.s */
	mcount += sprintf((sptr + mcount), "function myFunc(){\n");
	mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", SelectBtnDemoSTR);
	mcount += sprintf((sptr + mcount), "}\n"); 
    /* Java Scrupt code.m */
	if (1) //(refresh_continue)
	{
	 //mcount += sprintf((sptr + mcount), "function popbody() {\n");
	 //mcount += sprintf((sptr + mcount), "var Elems = document.getElementsByTagName(\"body\");\n"); //\r
	 //mcount += sprintf((sptr + mcount), "Elems[0].style.visibility = \"visible\";\n"); //\r
	 //mcount += sprintf((sptr + mcount), "}\n"); //\r
	   mcount += sprintf((sptr + mcount), "function popbody(){\n");
	   mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", pDemoSTR);
	   //mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", szOnLoadDemoSTR);
	   //mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", SelectOnDemoSTR);
	   //mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", SelectOffDemoSTR);
	   //mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", SelectFlashDemoSTR);
	   mcount += sprintf((sptr + mcount), "}\n");
	}
    /* Java Scrupt code.e */
#endif

  return mcount;
}
int page_start_meta_head_title3(char *sptr) //(, char refresh_continue)
{
  int mcount= 0;
    /* Java Scrupt code... */
	mcount += sprintf((sptr + mcount), "function onFunc(){\n");
	mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", szLedOpDemoSTR);
	mcount += sprintf((sptr + mcount), "}\n"); 
	mcount += sprintf((sptr + mcount), "function offFunc(){\n");
	mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", szLedOpDemoSTR);
	mcount += sprintf((sptr + mcount), "}\n"); 
	mcount += sprintf((sptr + mcount), "function flhFunc(){\n");
	mcount += sprintf((sptr + mcount), " document.getElementById(\"demo\").innerHTML = \"%s\";\n", szLedOpDemoSTR);
	mcount += sprintf((sptr + mcount), "}\n"); 
  return mcount;
}

// ----------------------------------------------------------------------------------------------------------

static unsigned short
page_header_pin0_a(void *arg)
{
  char *strptr= (char *)uip_appdata;
  int mcount= 0;
  mcount += sprintf((strptr + mcount),"<!DOCTYPE html>"); //(added )because IE8 and earlier support visibility:collapse only if a !DOCTYPE is specified.
  mcount += sprintf((strptr + mcount),"<html><head>"); //MCU - index
  mcount += sprintf((strptr + mcount), "<style type=\"text/css\">\n");
  mcount += page_start_meta_head_title1_a((strptr + mcount)); // (, (char)Get_DISPATCH_RefreshWebPage())
  return mcount;
}

static unsigned short
page_header_pin0_b(void *arg)
{
  char *strptr= (char *)uip_appdata;
  int mcount= 0;
  mcount += page_start_meta_head_title1_b((strptr + mcount)); 
  mcount += sprintf((strptr + mcount), "</style>\n");
  return mcount;
}

static unsigned short
page_header_pin1(void *arg)
{
	char *strptr= (char *)uip_appdata;
	int mcount= 0;
  mcount += sprintf((strptr + mcount), "<script>\n");
//mcount += sprintf((strptr + mcount), "<script type=\"text/javascript\">\n"); //\r
  mcount += page_start_meta_head_title2((strptr + mcount)); 
  return mcount;
}
static unsigned short
page_header_pin2(void *arg)
{
	char *strptr= (char *)uip_appdata;
	int mcount= 0;
  mcount += page_start_meta_head_title3((strptr + mcount)); 
  mcount += sprintf((strptr + mcount), "</script>\n"); 
  return mcount;
}

static unsigned short
page_body_pin(void *arg)
{
	char *strptr= (char *)uip_appdata;
	int mcount= 0;
  /*  style="visibility:hidden" in "<body>" */
#if 1
  /*
  if (refresh_continue)
   */
    mcount += sprintf((strptr + mcount), "</head>"); 
  //mcount += sprintf((strptr + mcount), "<body>");
  //mcount += sprintf((strptr + mcount), "<body style=\"visibility:visible\">"); //visible
  //mcount += sprintf((strptr + mcount), "<body style=\"visibility:hidden\" onload=\"popbody()\">");
  //mcount += sprintf((strptr + mcount), "<body style=\"visibility:collapse\" onload=\"popbody()\">"); 
    mcount += sprintf((strptr + mcount), "<body style=\"visibility:visible\" onload=\"popbody()\">"); 
    mcount += sprintf((strptr + mcount), "<div class=\"content\">");
    mcount += sprintf((strptr + mcount), "<div class=\"top_content\" style=\"width:auto;height:auto\">");
#endif  

  //mcount += sprintf((strptr + mcount),"<center>");
  #if 0
  //mcount += sprintf((strptr + mcount),
  //  "<h1>WEB - index (0x%02x, %d %d %d)</h1>", 
  //  Get_DISPATCH_ctl_bits(),
  //  0,
  //  Get_CurrPingEXE(),
  //  Get_EndPingEXE());
  #endif
    /* Java Scrupt code.s */ /*szDemoSTR= "About iProbe";*/
  mcount += sprintf((strptr + mcount),"<div class=\"top\">");  
  mcount += sprintf((strptr + mcount), "<p id=\"demo\">%s</p>", pDemoText); //szInitDemoSTR
  mcount += sprintf((strptr + mcount),"</div>");
  
  
  mcount += sprintf((strptr + mcount),"<div class=\"prgss\">");
  mcount += sprintf((strptr + mcount), "<button type=\"button\" onclick=\"myFunc()\">About</button>");
    /* Java Scrupt code.e */
  mcount += sprintf((strptr + mcount),"<center>");
  return mcount;
}

static unsigned short
page_footer(void *arg)
{
	char *strptr= (char *)uip_appdata;
	int mcount= 0;
  mcount += sprintf((strptr + mcount),"</div>");
  mcount += sprintf((strptr + mcount),"</div>");
  mcount += sprintf((strptr + mcount),"</div>");
  mcount += sprintf((strptr + mcount),"</body></html>"); //</center>
  return mcount;
}

  int index_p2_tab_row1(char *strptr, int mcount)
  {
    mcount += sprintf((strptr + mcount), "<tr><td colspan=4>"); //  width=516 border=1
    mcount += sprintf((strptr + mcount), "<FONT COLOR=#444444 FACE=\"Geneva, Arial\" SIZE=4>");
    #if 1
  //mcount += sprintf((strptr + mcount), "<FONT SIZE=4>MAC: </FONT>"); //  width=90 HEIGHT=15, width=15, width=55
    mcount += sprintf((strptr + mcount), "<B>MAC: </B>");
  //mcount += sprintf((strptr + mcount), "</td><td>");
    mcount += sprintf((strptr + mcount), "%02x:%02x:%02x:%02x:%02x:%02x", 
						(unsigned int)uip_ethaddr.addr[0], 
						(unsigned int)uip_ethaddr.addr[1], 
						(unsigned int)uip_ethaddr.addr[2], 
						(unsigned int)uip_ethaddr.addr[3], 
						(unsigned int)uip_ethaddr.addr[4], 
						(unsigned int)uip_ethaddr.addr[5]);
  //mcount += sprintf((strptr + mcount),"</td>"); 
  //mcount += sprintf((strptr + mcount),"</tr>"); 
    mcount += sprintf((strptr + mcount),"<br>"); 
  //mcount += sprintf((strptr + mcount),"<tr>"); 
  //mcount += sprintf((strptr + mcount),"<td>"); 
  //mcount += sprintf((strptr + mcount), "<FONT SIZE=4>IP: </FONT>"); // width=90 HEIGHT=15, width=15, width=55
    mcount += sprintf((strptr + mcount), "<B>IP: </B>");
  //mcount += sprintf((strptr + mcount), "</td><td>");
    mcount += sprintf((strptr + mcount), "%d.%d.%d.%d",
    					(uip_hostaddr[0]&0xff), ((uip_hostaddr[0] >> 8)&0xff),
						(uip_hostaddr[1]&0xff), ((uip_hostaddr[1] >> 8)&0xff));
    #endif
    mcount += sprintf((strptr + mcount), "</FONT>");
    mcount += sprintf((strptr + mcount), "</td></tr>"); //</form>
    return mcount;
  }
  int index_p2_tab_row2(char *strptr, int mcount)
  {
	  //mcount += sprintf((strptr + mcount), "&nbsp;");
    mcount += sprintf((strptr + mcount), "<tr><td width=19%c>", '%');
      //mcount += sprintf((strptr + mcount), "<FONT SIZE=4>");
      mcount += sprintf((strptr + mcount), "<B>LED Test</B>"); 
      //mcount += sprintf((strptr + mcount), "</FONT>");
      mcount += sprintf((strptr + mcount), "</td>");
    
      //mcount += sprintf((strptr + mcount), "<FONT SIZE=2>");
      mcount += sprintf((strptr + mcount), "<td width=27%c align=center>", '%');
	    mcount += sprintf((strptr + mcount), "<a href=\"1\" onclick=\"onFunc()\">"); //192.168.1.232/
	    mcount += sprintf((strptr + mcount), "ON</a>");
      mcount += sprintf((strptr + mcount), "</td>");
      mcount += sprintf((strptr + mcount), "<td width=27%c align=center>", '%');
	    mcount += sprintf((strptr + mcount), "<a href=\"0\" onclick=\"offFunc()\">"); //192.168.1.232/
	    mcount += sprintf((strptr + mcount), "OFF</a>");
        mcount += sprintf((strptr + mcount), "</td>");
        mcount += sprintf((strptr + mcount), "<td align=center>");
	    mcount += sprintf((strptr + mcount), "<a href=\"2\" onclick=\"flhFunc()\">"); //192.168.1.232/
	    mcount += sprintf((strptr + mcount), "Flash</a>");
      mcount += sprintf((strptr + mcount), "</td>");
      //mcount += sprintf((strptr + mcount), "</FONT>");
    mcount += sprintf((strptr + mcount), "</tr>"); //</form>
    return mcount;
  }
  int index_p3_table(char *strptr, int mcount)
  {
	    mcount += sprintf((strptr + mcount),"<tr>"); 
	    	mcount += sprintf((strptr + mcount),"<td>"); // width=56 ALIGN=left
	    	mcount += sprintf((strptr + mcount),"<FONT COLOR=#444444>"); // COLOR=#448888 FACE=\"Geneva, Arial\" SIZE=5	
	        mcount += sprintf((strptr + mcount), "GPIO: "); 
	        //mcount += sprintf((strptr + mcount),"</FONT></td>"); 
	        mcount += sprintf((strptr + mcount), "  ");
	        mcount += sprintf((strptr + mcount), "P77 ");
	        mcount += sprintf((strptr + mcount), "%s", sCurrLED); // "on/off"
	        //mcount += sprintf((strptr + mcount),"<td width=96 ALIGN=right><FONT SIZE=5>"); 
	        mcount += sprintf((strptr + mcount), "  ");
	        mcount += sprintf((strptr + mcount), "P05 ");
	        mcount += sprintf((strptr + mcount), "%s", sCurrP05); // "high/low"
	    	//mcount += sprintf((strptr + mcount),"</FONT></td>"); 
	    	//mcount += sprintf((strptr + mcount),"<td width=82 ALIGN=right><FONT SIZE=5>");
	        //mcount += sprintf((strptr + mcount), "  ");
	        //mcount += sprintf((strptr + mcount), "·Å«× ");
	        //mcount += sprintf((strptr + mcount), "%d", Curr.Tmp);
	    	//mcount += sprintf((strptr + mcount),"</FONT></td>"); 	
	    	//mcount += sprintf((strptr + mcount),"<td width=70 ALIGN=right><FONT SIZE=5>");
	        //mcount += sprintf((strptr + mcount), "  ");
	        //mcount += sprintf((strptr + mcount), "Àã«× ");
	        //mcount += sprintf((strptr + mcount), "%d", Curr.Hum);    
	    	mcount += sprintf((strptr + mcount),"</FONT>");    
	    	mcount += sprintf((strptr + mcount),"</td>"); 	
	    	mcount += sprintf((strptr + mcount),"<td ALIGN=right>"); // width=126
	      	mcount += sprintf((strptr + mcount), "<a href=\"home.html\">");
	      	mcount += sprintf((strptr + mcount), "SensorPage</a>");
	    	mcount += sprintf((strptr + mcount),"</td>");
	    mcount += sprintf((strptr + mcount),"</tr>");
	    return mcount;
  }  
	
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

//void sniffer_script(struct httpd_state *s)
//{
//    PSOCK_GENERATOR_SEND(&s->sout, page_header_pin1, s);
//    PSOCK_GENERATOR_SEND(&s->sout, page_header_pin2, s);
//}
static 
int page_tabe0(char *p){
  int mcount= 0;
  mcount += sprintf((p + mcount),"<table width=%d border BGCOLOR=SkyBlue>", MAX_WIDTH_PX - IN_PADDING_WIDTH); //BGCOLOR=#77FF77,BGCOLOR=SkyBlue //BGCOLOR=#77FFFF
  mcount= index_p2_tab_row1(p, mcount); // over-html.c
  return mcount;
}
static
unsigned short pin_tab0(void *arg){
  char *strptr= (char *)uip_appdata;
  int mcount= 0;
  mcount += page_tabe0(strptr+mcount);
  return mcount;
}
static unsigned short
pin_tab1(void *arg)
{
	char *strptr= (char *)uip_appdata;
	int mcount= 0;
  mcount= index_p2_tab_row2(strptr, mcount); // over-html.c
  mcount += sprintf((strptr + mcount), "</table>");
  return mcount;
}
static unsigned short
pin_tab2_EndBR(void *arg)
{
	char *strptr= (char *)uip_appdata;
	int mcount= 0;
  mcount += sprintf((strptr + mcount),"<table width=%d>", MAX_WIDTH_PX- IN_PADDING_WIDTH);
  mcount= index_p3_table(strptr, mcount);
  mcount += sprintf((strptr + mcount), "</table>"); 
  mcount += sprintf((strptr + mcount),"<br>"); 
  return mcount;
}
static unsigned short
html_center_End(void *arg)
{
  char *strptr= (char *)uip_appdata;
  int mcount= 0;
  mcount += sprintf((strptr + mcount), "</center>\r\n"); 
  return mcount;
}

unsigned short
table_row(void *arg)
{
  return (int) arg;
}
unsigned short
table_icmp_color_tabend(void *arg)
{
	char *strptr= (char *)uip_appdata;
	int mcount= 0;
  mcount += sprintf((strptr + mcount),"</table>");
  return mcount;
}

// ----------------------------------------------------------------------------------------------------------
char /*bit*/ chk_arp_byIdex(u8_t adrr)
{
  return 0;
  //int i;
  //struct arp_entry *tabptr;
  //  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
  //    tabptr = &arp_table[i];
  //    if (adrr && (adrr == uip_ipaddr4(tabptr->ipaddr))) //if (uip_ipaddr_cmp(g_ipaddr, tabptr->ipaddr)) 
  //    {
  //    return 1;
  //    }
  //  }
  //  return 0;
}
char uip_icmptab_InNodes(u8_t id)
{
  return 0;
	//u8_t ipbegin= keeper_Begin;
	//u8_t ipend= keeper_IPNode;
	//if (ipend==0)
	//	return (id >= ipbegin);
	//else
	//	return (id>=ipbegin) && (id<ipend);
}
int one_block(char *strptr, int mcount)
{
	int smcount= mcount;
	u8_t id= probe_index;
	char stat= uip_icmptab_InNodes(id); //uip_icmptab_find(id);
	char exist= (char)icmptab_get_arp_wbit(id);
	char arpflg= (char)chk_arp_byIdex(id);
	 
	if (id==BROWSERIP3) {
	  mcount += sprintf((strptr + mcount),"<input type=x class=w value=%d disabled>\r\n", id);
	  probe_fc++;
	} else if (id==DMIP3) {
	  mcount += sprintf((strptr + mcount),"<input type=y class=w value=%d disabled>\r\n", id);
	  probe_fc++;
	} else if (exist | arpflg) {
	  mcount += sprintf((strptr + mcount),"<input type=b class=w value=%d disabled>\r\n", id);
	  probe_fc++;
	} else if (stat)
	  mcount += sprintf((strptr + mcount),"<input type=r class=w>\r\n"); //value=. //BGCOLOR=#77FF77 
	else
	  mcount += sprintf((strptr + mcount),"<input type=r class=w value=.>\r\n");
	 
	return mcount-smcount;
}
// ----------------------------------------------------------------------------------------------------------
int tabstart_bkgndcolor(int mcount)
{
  char *strptr= (char *)uip_appdata + mcount;
  int addcount;
  
  /* char stat= uip_icmptab_InNodes(probe_index); */
  
  if (uip_icmptab_InNodes(probe_index)) //uip_icmptab_find(id);
    addcount = sprintf(strptr,"<table BGCOLOR=#EED0D0>");
  
  else if (probe_index < 128)
    addcount = sprintf(strptr,"<table BGCOLOR=#B0EED0>");
  else 
    addcount = sprintf(strptr,"<table BGCOLOR=#80F080>");
    
  return addcount;
}
int trtds(int mcount)
{
  char *strptr= (char *)uip_appdata + mcount;
  int addcount= sprintf(strptr,"<tr><td bordercolor=#F0F0F0 align=left>\r\n");
  return addcount;
}
int trtde(int mcount)
{
  char *strptr= (char *)uip_appdata + mcount;
  int addcount;
  addcount= sprintf(strptr,"<input type=sbx class=w value=(%d)><input type=cbx class=w value=%d></td></tr>\r\n", probe_fc, probe_fc - probc_prev);
  probc_prev= probe_fc;
  return addcount;
}
int one_const(int mcount, int val)
{
  char *strptr= (char *)uip_appdata + mcount;
#if 1
//org
  return sprintf(strptr,"<input type=b class=w value=%d>\r\n", val); /* Test disable added & for cell use this!!*/
#else
//test
  return sprintf(strptr,"<input type=y class=w value=%d disabled>\r\n", val);
#endif  
}
int one_content(int mcount)
{
  char *strptr= (char *)uip_appdata + mcount;
  return one_block(strptr, 0);
}

int compose_table_row(u8_t j, u8_t i, int mcount)
{
  int smcount= mcount;
  			//char *strptr= (char *)uip_appdata + mcount;
			//if (!i) PSOCK_GENERATOR_SEND(&s->sout, tabstart_backgroundcolor, s);
			//if (!i) PSOCK_GENERATOR_SEND(&s->sout, trtdstart, s);
			//if (!i && !j) PSOCK_GENERATOR_SEND(&s->sout, one_color_const0, s);
			//else if (i==15 && j==15) PSOCK_GENERATOR_SEND(&s->sout, one_color_const255, s);
			//else PSOCK_GENERATOR_SEND(&s->sout, one_color_content, s);
			//if (i==15) PSOCK_GENERATOR_SEND(&s->sout, trtdend, s);
  if (!i) mcount += tabstart_bkgndcolor(mcount);
  if (!i) mcount += trtds(mcount);

  if (!i && !j) mcount += one_const(mcount, 0);
  else if (i==15 && j==15) mcount += one_const(mcount, 255);
  else mcount += one_content(mcount);

  if (i==15) mcount += trtde(mcount);
  return mcount - smcount;
}
// ----------------------------------------------------------------------------------------------------------

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
static unsigned short
generate_part_of_file(void *state)
{
  struct httpd_state *s = (struct httpd_state *)state;

  if(s->file.len > uip_mss()) {
    s->len = uip_mss();
  } else {
    s->len = s->file.len;
  }
  memcpy(uip_appdata, s->file.data, s->len);
  
  return s->len;
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_file(struct httpd_state *s))
{
  PSOCK_BEGIN(&s->sout);
  
  do {
    PSOCK_GENERATOR_SEND(&s->sout, generate_part_of_file, s);
    s->file.len -= s->len;
    s->file.data += s->len;
  } while(s->file.len > 0);
      
  PSOCK_END(&s->sout);
}

/*---------------------------------------------------------------------------*/
u16_t Get_DISPATCH_ctl_bits(void){
  return 0xff; //return dsptch_ctl_bits;
}
u8_t Get_CurrPingEXE(void){
  return 1; //return dsptch_ctl_ping_ExeDAT;
}
u8_t Get_EndPingEXE(void){
  return 9; //return PING_STEP9;
}
static 
int page_icmp_fc_start(char *p){
  int mcount= 0;
  mcount += sprintf((p + mcount),"<table width=%d border=1 CELLPADDING=5 align=center>", MAX_WIDTH_PX- IN_PADDING_WIDTH);
  mcount += sprintf((p + mcount),"<tr align=center>");
   // Green bkgnd color (blank) 
   mcount += sprintf((p + mcount),"<td colspan=2 BGCOLOR=#77FF77>");
   mcount += sprintf((p + mcount), "WEB - index (0x%02x, %d %d %d)", 
    Get_DISPATCH_ctl_bits(), 0, 
    Get_CurrPingEXE(), 
    Get_EndPingEXE());
   mcount += sprintf((p + mcount),"</td>");
  mcount += sprintf((p + mcount),"</tr>"); 
  mcount += sprintf((p + mcount),"<tr align=left>");
  mcount += sprintf((p + mcount),"<td colspan=2>IPT:\r\n"); 
  return mcount;
}
unsigned short table_icmp_fc_Start(void *arg)
{
  char *strptr= (char *)uip_appdata;  //BGCOLOR=#EEEEDD v.s. Linen (#FAF0E6), Silver (#C0C0C0) align="center|right"
  int mcount= 0;
  mcount += page_icmp_fc_start(strptr + mcount);
  return mcount;
}
unsigned short
dispIPT_row(void *arg)
{
  return (int) arg;
}
unsigned short table_icmp_fc_Mid(void *arg)
{
	char *strptr= (char *)uip_appdata; 
	int mcount= 0;
  mcount += sprintf((strptr + mcount),"</td>"); 
  mcount += sprintf((strptr + mcount),"</tr>"); 
  mcount += sprintf((strptr + mcount),"<tr align=left>");
  mcount += sprintf((strptr + mcount),"<td width=20%c>", '%'); //[But get 5% like for this col.]
  mcount += sprintf((strptr + mcount),"IPT Total: <input style=text-align:center; size=2 value=%d>", probe_dispc); 
  mcount += sprintf((strptr + mcount),"</td>"); 
  	mcount += sprintf((strptr + mcount),"<td>"); //width=5%
  return mcount;
}
unsigned short table_icmp_fc_Clear(void *arg)
{
  char *strptr= (char *)uip_appdata; 
  int mcount= 0;
    mcount += sprintf((strptr + mcount), "<a href=\"5\">");
    mcount += sprintf((strptr + mcount), "Clear</a>");
  return mcount;
}
static 
int page_icmp_fc_end(char *p){
  int mcount= 0;
  mcount += sprintf((p + mcount),"</td>");
  mcount += sprintf((p + mcount),"</tr>");  
  mcount += sprintf((p + mcount),"</table>"); 
  return mcount;
}
int icmp_fc_dispARP(char *strptr, int smcount)
{
  int i, c= 0;
  int mcount= smcount;
  mcount += sprintf((strptr + mcount),"ARP:");
  for (i=1; i< 256; i++)
    if (chk_arp_byIdex((u8_t)i))
    		c++;
  if (c) mcount += sprintf((strptr + mcount)," total %d", c); 
  else   mcount += sprintf((strptr + mcount)," (empty)");
  return mcount - smcount;
}
unsigned short table_icmp_fc_End(void *arg){
  char *strptr= (char *)uip_appdata; 
  int mcount= 0;
  mcount += page_icmp_fc_end(strptr+mcount);
  mcount += icmp_fc_dispARP(strptr, mcount);
  return mcount;
}

/*---------------------------------------------------------------------------*/
int compose_dispIPT(int mcount, u8_t i)
{
	int smcount= mcount;
  	char *strptr= (char *)uip_appdata; // + mcount;
  	
	if (i==1) probe_dispc= 0; //if (i==0) 
    if (icmptab_get_arp_wbit((u8_t)i)){
  		probe_dispc++;
  		mcount += sprintf((strptr + mcount)," %d", i); 
    } else
    if (chk_arp_byIdex((u8_t)i)){
    		if (i>=10) mcount += sprintf((strptr + mcount)," ");
    		if (i>=100) mcount += sprintf((strptr + mcount)," ");
  		mcount += sprintf((strptr + mcount)," *");
    }
    if (i==0xff && !probe_dispc) mcount += sprintf((strptr + mcount)," (empty)"); 
	return mcount - smcount;	
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_sniffer_generator_send(struct httpd_state *s))
{
  PSOCK_BEGIN(&s->sout);
    PSOCK_GENERATOR_SEND(&s->sout, page_header_pin0_a, s);
    PSOCK_GENERATOR_SEND(&s->sout, page_header_pin0_b, s);
    
		//sniffer_script.s(s); //PSOCK_BEGIN(&s->sout);
    PSOCK_GENERATOR_SEND(&s->sout, page_header_pin1, s);
    PSOCK_GENERATOR_SEND(&s->sout, page_header_pin2, s);
		//sniffer_script.e(s); //PSOCK_END(&s->sout);
	
    PSOCK_GENERATOR_SEND(&s->sout, page_body_pin, s);
	
		//sniffer_ipt_table(s);
    PSOCK_GENERATOR_SEND(&s->sout, table_icmp_fc_Start, s);
    //PSOCK_GENERATOR_SEND(&s->sout, table_icmp_fc_dispIPT, s);
    //=
			probe_index= 1; //0;
			do {
			int mcount= 0;
#if 1				
			mcount += compose_dispIPT(mcount, probe_index);
			do {
				probe_index++;
				mcount += compose_dispIPT(mcount, probe_index);
				if (mcount >= (uip_mss() - LEN_IF_TAB_CONCLUSION)) {
					PSOCK_GENERATOR_SEND(&s->sout, dispIPT_row, (void *)mcount);
					mcount= 0;
				}
			} while (probe_index!=0xff);
#endif
			if (mcount) PSOCK_GENERATOR_SEND(&s->sout, dispIPT_row, (void *)mcount);
			} while(0);
    PSOCK_GENERATOR_SEND(&s->sout, table_icmp_fc_Mid, s);
    PSOCK_GENERATOR_SEND(&s->sout, table_icmp_fc_Clear, s);
    PSOCK_GENERATOR_SEND(&s->sout, table_icmp_fc_End, s); //'table_icmp_fc_EndBR'
	//...
		//sniffer_rpt_table(s);
    PSOCK_GENERATOR_SEND(&s->sout, pin_tab0, s); // or 'pin_tab0_BR'
    PSOCK_GENERATOR_SEND(&s->sout, pin_tab1, s);
    PSOCK_GENERATOR_SEND(&s->sout, pin_tab2_EndBR, s);
    PSOCK_GENERATOR_SEND(&s->sout, html_center_End, PSCK_ARG_NoUSE);
		//for (j=0; j<16; j++)
		//	for (int i=0; i<16; i++) { /* tabstart 16 times work with tabend 1 time */
		//		if (!i) PSOCK_GENERATOR_SEND(&s->sout, tabstart_backgroundcolor, s);
		//		if (!i) PSOCK_GENERATOR_SEND(&s->sout, trtdstart, s);
		//		if (!i && !j) PSOCK_GENERATOR_SEND(&s->sout, one_color_const0, s);
		//		else if (i==15 && j==15) PSOCK_GENERATOR_SEND(&s->sout, one_color_const255, s);
		//		else PSOCK_GENERATOR_SEND(&s->sout, one_color_content, s);
		//		if (i==15) PSOCK_GENERATOR_SEND(&s->sout, trtdend, s);
		//		probe_index++;
		//	}

		// #define PSCK_ARG_NoUSE NULL //('arg' is to be not used!)
		// You can not : PSOCK_GENERATOR_SEND(&s->sout, mcount, (void *)PSCK_ARG_NoUSE);  
		//             : So that 'mcount' will be called play as a function.
		probe_index= probe_fc= probc_prev= 0;
		do {
			int mcount= 0;
	#if 1
			mcount += compose_table_row((probe_index&0x0f>>4), (probe_index&0x0f), mcount);
			do {
				//for (gj=0; gj<16; gj++){
					probe_index++;
					mcount += compose_table_row((probe_index>>4), (probe_index&0x0f), mcount);
							
					if (mcount >= (uip_mss() - LEN_IF_TAB_CONCLUSION)) {
						PSOCK_GENERATOR_SEND(&s->sout, table_row, (void *)mcount); 
						mcount= 0;
					}
				//}
			} while(probe_index!=0xff); //while(probe_index!=0x0f); //while(probe_index<24); //while(probe_index!=0xff);
			//org - ne need this below line.
			if (mcount) PSOCK_GENERATOR_SEND(&s->sout, table_row, (void *)mcount); 
			PSOCK_GENERATOR_SEND(&s->sout, table_icmp_color_tabend, PSCK_ARG_NoUSE);
	#endif
		} while(0);
	
    PSOCK_GENERATOR_SEND(&s->sout, page_footer, s);
  PSOCK_END(&s->sout);
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_part_of_file(struct httpd_state *s))
{
  PSOCK_BEGIN(&s->sout);

  PSOCK_SEND(&s->sout, s->file.data, s->len);
  
  PSOCK_END(&s->sout);
}
/*---------------------------------------------------------------------------*/
static void
next_scriptstate(struct httpd_state *s)
{
  char *p;
  p = strchr(s->scriptptr, ISO_nl) + 1;
  s->scriptlen -= (unsigned short)(p - s->scriptptr);
  s->scriptptr = p;
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_script(struct httpd_state *s))
{
  char *ptr;
  
  PT_BEGIN(&s->scriptpt);


  while(s->file.len > 0) {

    /* Check if we should start executing a script. */
    if(*s->file.data == ISO_percent &&
       *(s->file.data + 1) == ISO_bang) {
      s->scriptptr = s->file.data + 3;
      s->scriptlen = s->file.len - 3;
      if(*(s->scriptptr - 1) == ISO_colon) {
	httpd_fs_open(s->scriptptr + 1, &s->file);
	PT_WAIT_THREAD(&s->scriptpt, send_file(s));
      } else {
	PT_WAIT_THREAD(&s->scriptpt,
		       httpd_cgi(s->scriptptr)(s, s->scriptptr));
      }
      next_scriptstate(s);
      
      /* The script is over, so we reset the pointers and continue
	 sending the rest of the file. */
      s->file.data = s->scriptptr;
      s->file.len = s->scriptlen;
    } else {
      /* See if we find the start of script marker in the block of HTML
	 to be sent. */

      if(s->file.len > uip_mss()) {
	s->len = uip_mss();
      } else {
	s->len = s->file.len;
      }

      if(*s->file.data == ISO_percent) {
	ptr = strchr(s->file.data + 1, ISO_percent);
      } else {
	ptr = strchr(s->file.data, ISO_percent);
      }
      if(ptr != NULL &&
	 ptr != s->file.data) {
	s->len = (int)(ptr - s->file.data);
	if(s->len >= uip_mss()) {
	  s->len = uip_mss();
	}
      }
      PT_WAIT_THREAD(&s->scriptpt, send_part_of_file(s));
      s->file.data += s->len;
      s->file.len -= s->len;
      
    }
  }
  
  PT_END(&s->scriptpt);
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_headers(struct httpd_state *s, const char *statushdr))
{
  char *ptr;

  PSOCK_BEGIN(&s->sout);

  PSOCK_SEND_STR(&s->sout, statushdr);

  ptr = strrchr(s->filename, ISO_period);
  if(ptr == NULL) {
    PSOCK_SEND_STR(&s->sout, http_content_type_binary);
  } else if(strncmp(http_html, ptr, 5) == 0 ||
	    strncmp(http_shtml, ptr, 6) == 0) {
    PSOCK_SEND_STR(&s->sout, http_content_type_html);
  } else if(strncmp(http_css, ptr, 4) == 0) {
    PSOCK_SEND_STR(&s->sout, http_content_type_css);
  } else if(strncmp(http_png, ptr, 4) == 0) {
    PSOCK_SEND_STR(&s->sout, http_content_type_png);
  } else if(strncmp(http_gif, ptr, 4) == 0) {
    PSOCK_SEND_STR(&s->sout, http_content_type_gif);
  } else if(strncmp(http_jpg, ptr, 4) == 0) {
    PSOCK_SEND_STR(&s->sout, http_content_type_jpg);
  } else {
    PSOCK_SEND_STR(&s->sout, http_content_type_plain);
  }
  PSOCK_END(&s->sout);
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_output(struct httpd_state *s))
{
  char *ptr;
  
  PT_BEGIN(&s->outputpt);
 
  if(!httpd_fs_open(s->filename, &s->file)) {
    httpd_fs_open(http_404_html, &s->file);
    strcpy(s->filename, http_404_html);
    PT_WAIT_THREAD(&s->outputpt,
		   send_headers(s,
		   http_header_404));
    PT_WAIT_THREAD(&s->outputpt,
		   send_file(s));
  } else {
    PT_WAIT_THREAD(&s->outputpt,
		   send_headers(s,
		   http_header_200));
		
    ptr = strchr(s->filename, ISO_period);
		
    //added.jj
    if (httpd_fs_strcmp(s->filename, http_sniffer_shtml) == 0) { //added.jj
			/* icmptab_init_arp_wbit(); */
      PT_WAIT_THREAD(&s->outputpt, handle_sniffer_generator_send(s));
    } else //added.jj
		
    if(ptr != NULL && strncmp(ptr, http_shtml, 6) == 0) {
      PT_INIT(&s->scriptpt);
      PT_WAIT_THREAD(&s->outputpt, handle_script(s));
    } else {
      PT_WAIT_THREAD(&s->outputpt,
		     send_file(s));
    }
  }
  PSOCK_CLOSE(&s->sout);
  PT_END(&s->outputpt);
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_input(struct httpd_state *s))
{
  PSOCK_BEGIN(&s->sin);

  PSOCK_READTO(&s->sin, ISO_space);

  
  if(strncmp(s->inputbuf, http_get, 4) != 0) {
    PSOCK_CLOSE_EXIT(&s->sin);
  }
  PSOCK_READTO(&s->sin, ISO_space);

  if(s->inputbuf[0] != ISO_slash) {
    PSOCK_CLOSE_EXIT(&s->sin);
  }

  if(s->inputbuf[1] == ISO_space) {		
    //strncpy(s->filename, http_index_html, sizeof(s->filename));
		strncpy(s->filename, http_sniffer_shtml, sizeof(s->filename));
  } 
#if 1 //Joseph add
	/* Control led, 0 = OFF, 1 = ON, 2 = Flash */
  else if (s->inputbuf[3] == 'L','E','D' && ((s->inputbuf[4] == '0') || 
						(s->inputbuf[4] == '1') || (s->inputbuf[4] == '2'))){
  	
    Set_LED_mode(s->inputbuf[4]);
    s->inputbuf[4]= 0;
    //strncpy(s->filename, "/home.html", 10);
		strncpy(s->filename, http_webMain_html, sizeof(s->filename));
	}
#endif
	else {
    s->inputbuf[PSOCK_DATALEN(&s->sin) - 1] = 0;
    strncpy(s->filename, &s->inputbuf[0], sizeof(s->filename));
  }

  /*  httpd_log_file(uip_conn->ripaddr, s->filename);*/
  
  s->state = STATE_OUTPUT;

  while(1) {
    PSOCK_READTO(&s->sin, ISO_nl);

    if(strncmp(s->inputbuf, http_referer, 8) == 0) {
      s->inputbuf[PSOCK_DATALEN(&s->sin) - 2] = 0;
      /*      httpd_log(&s->inputbuf[9]);*/
    }
  }
  
  PSOCK_END(&s->sin);
}
/*---------------------------------------------------------------------------*/
static void
handle_connection(struct httpd_state *s)
{
  handle_input(s);
  if(s->state == STATE_OUTPUT) {
    handle_output(s);
  }
}
/*---------------------------------------------------------------------------*/
void
httpd_appcall(void)
{
  struct httpd_state *s = (struct httpd_state *)&(uip_conn->appstate);

  if(uip_closed() || uip_aborted() || uip_timedout()) {
  } else if(uip_connected()) {
    PSOCK_INIT(&s->sin, s->inputbuf, sizeof(s->inputbuf) - 1);
    PSOCK_INIT(&s->sout, s->inputbuf, sizeof(s->inputbuf) - 1);
    PT_INIT(&s->outputpt);
    s->state = STATE_WAITING;
    /*    timer_set(&s->timer, CLOCK_SECOND * 100);*/
    s->timer = 0;
    handle_connection(s);
  } else if(s != NULL) {
    if(uip_poll()) {
      ++s->timer;
      if(s->timer >= 20) {
	uip_abort();
      }
    } else {
      s->timer = 0;
    }
    handle_connection(s);
  } else {
    uip_abort();
  }
}
/*---------------------------------------------------------------------------*/
/**
 * \brief      Initialize the web server
 *
 *             This function initializes the web server and should be
 *             called at system boot-up.
 */
void
httpd_init(void)
{
  uip_listen(HTONS(80));
	icmptab_init_arp_wbit(); // sniffer.jj
}
/*---------------------------------------------------------------------------*/
/** @} */
